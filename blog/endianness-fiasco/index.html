<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="text/html; charset=UTF-8" http-equiv=content-type><meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport><meta content="index, follow" name=robots><title>Endianness Fiasco</title><meta content="Endianness Fiasco" name=title><meta content=Karthik name=author><meta content="Personal Commentary" name=description><meta content=website property=og:type><meta content=https://Karthik-d-k.github.io/blog/endianness-fiasco/ property=og:url><meta content=0x646b property=og:site_name><meta content="Endianness Fiasco" property=og:title><meta content="Personal Commentary" property=og:description><meta content=https://Karthik-d-k.github.io/favicon.ico property=og:image><meta content=summary_large_image property=twitter:card><meta content=https://Karthik-d-k.github.io/blog/endianness-fiasco/ property=twitter:url><meta content="Endianness Fiasco" property=twitter:title><meta content="Personal Commentary" property=twitter:description><meta content=https://Karthik-d-k.github.io/favicon.ico property=twitter:image><link href=https://Karthik-d-k.github.io/blog/endianness-fiasco/ rel=canonical><link rel="shortcut icon" href=https://Karthik-d-k.github.io/favicon.ico type=image/x-icon><link href=https://Karthik-d-k.github.io/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://speyll.github.io/suCSS/reset-min.css rel=stylesheet><link href=https://speyll.github.io/suCSS/suCSS-min.css rel=stylesheet><link href=https://Karthik-d-k.github.io/css/style.css rel=stylesheet><script defer src=https://Karthik-d-k.github.io/js/script.js></script><body><header><nav id=nav-bar><a href=/> /home </a><a href=/blog> /blog </a><a href=/til> /til </a><a href=/projects> /projects </a><a href=/tags> /tags </a><a href=/bookmarks> /bookmarks </a><a href=/cv> /cv </a><a href=# id=search-trigger> ðŸ”Ž </a><div><input id=theme-toggle style=display:none type=checkbox><label for=theme-toggle id=theme-toggle-label><svg class=icons id=theme-icon><use href=https://Karthik-d-k.github.io/icons.svg#lightMode></use></svg></label><audio id=theme-sound><source src=https://Karthik-d-k.github.io/click.ogg type=audio/ogg></audio></div></nav></header><main><h1>Endianness Fiasco</h1><h2 id=motivation>Motivation</h2><p>Iâ€™m from embedded background and I deal with hardware. Often, we deal with bitwise operations to manipulate data at the bit level. One of the common challenges that arise in such scenarios is endianness - the order in which bytes are arranged within larger data types. Only if we know how the data is stored, we can correctly interpret and manipulate it.<h2 id=endianness>Endianness</h2><p>Endianness defines how <code>multi-byte data</code> will be <code>stored</code> in our <code>computer memory</code>.<br> <strong>Big-endian</strong> and <strong>Little-endian</strong> are the types widely used; other types may not be relevant to most users. explore <a href=https://en.wikipedia.org/wiki/Endianness rel=noopener target=_blank>wiki</a> for this.<blockquote><p>Smallest addressable unit of data in current computing systems is <code>byte (8-bits)</code>.</blockquote><p>Endianness comes into the picture when we try to <em>read/write multi-byte data</em>. Endianness does not matter if you have a <em>single byte</em>.<ol><li><p><strong>Big-endian</strong>: When we store multi-byte data, the most-significant byte will be stored at the lowest addressed memory.</p><li><p><strong>Little-endian</strong>: When we store multi-byte data, the least-significant byte will be stored at the lowest addressed memory.</p></ol><p>We can visualize this difference by running the following <strong>c code snippet</strong>.<p><strong>Snippet 1:</strong><pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdio.h</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdint.h</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>endian.h</span><span>>  </span><span style=color:#65737e>// GNU/Linux (glibc). Not portable to Windows/MSVC.
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>(</span><span style=color:#b48ead>void</span><span>) {          
</span><span>    uint16_t data_u16 = </span><span style=color:#d08770>0x1122</span><span>;
</span><span>    uint16_t u16_be = </span><span style=color:#bf616a>htobe16</span><span>(data_u16);    </span><span style=color:#65737e>// Store 16-bit data in big-endian format
</span><span>    uint16_t u16_le = </span><span style=color:#bf616a>htole16</span><span>(data_u16);    </span><span style=color:#65737e>// Store 16-bit data in little-endian format
</span><span>
</span><span>    uint8_t* u8p_be = (uint8_t *)&u16_be;   </span><span style=color:#65737e>// Point to lowest address of `be` data
</span><span>    uint8_t* u8p_le = (uint8_t *)&u16_le;   </span><span style=color:#65737e>// Point to lowest address of `le` data
</span><span>
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>data_u16  = </span><span style=color:#d08770>%#x</span><span style=color:#96b5b4>\n</span><span>", data_u16);
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>u8p_be[0] = </span><span style=color:#d08770>%#x</span><span style=color:#96b5b4>\n</span><span>", *u8p_be);
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>u8p_le[0] = </span><span style=color:#d08770>%#x</span><span style=color:#96b5b4>\n</span><span>", *u8p_le);
</span><span>
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span><span>
</span></code></pre><p><strong>Snippet 1 stdout:</strong><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>data_u16</span><span>  = 0x1122
</span><span style=color:#bf616a>u8p_be[0]</span><span> = 0x11
</span><span style=color:#bf616a>u8p_le[0]</span><span> = 0x22
</span></code></pre><ul><li>Letâ€™s assume our 16-bit data is <strong>0x1122</strong> wherein <strong>0x11</strong> is the most-significant byte and <strong>0x22</strong> is the least-significant byte.<li>Here, Iâ€™m using <code>htobe16</code> and <code>htole16</code> functions from <code>endian.h</code> to simulate big- and little-endian representations. Note: <code>endian.h</code> is GNU-specific; on other platforms you may use <code>htons</code>/<code>ntohs</code> or manual byte operations.<li>By reading the first byte stored at the lowest address of our data, we get to know that a LE machine stores the least-significant byte and a BE machine stores the most-significant byte.</ul><p>Using the above example with slight modification, we could get to know our machineâ€™s endianness.<p><strong>Snippet 2:</strong><pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdio.h</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdint.h</span><span>>
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>(</span><span style=color:#b48ead>void</span><span>) {          
</span><span>    uint16_t u16 = </span><span style=color:#d08770>0x1122</span><span>;
</span><span>    uint8_t* u8p = (uint8_t *)&u16; 
</span><span>
</span><span>    </span><span style=color:#b48ead>if </span><span>((*u8p) == </span><span style=color:#d08770>0x22</span><span>) {
</span><span>        </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>LITTLE ENDIAN</span><span style=color:#96b5b4>\n</span><span>");
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>BIG ENDIAN</span><span style=color:#96b5b4>\n</span><span>");
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span><span>
</span></code></pre><p><strong>Snippet 2 stdout:</strong><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>LITTLE</span><span> ENDIAN
</span></code></pre><h2 id=bit-twiddling>Bit Twiddling</h2><p>I will explain how to set/clear the bits in a multi-byte data by taking endianness into account. Letâ€™s say we have a 32-bit data and we had to set the 25th bit and clear the 6th bit, the usual way is to use a bit-mask and do bit-wise operations as shown in the below snippet:<p><strong>Snippet 3:</strong><pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdio.h</span><span>>
</span><span style=color:#b48ead>#include </span><span>&lt;</span><span style=color:#a3be8c>stdint.h</span><span>>
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>(</span><span style=color:#b48ead>void</span><span>) {          
</span><span>    uint32_t u32_in = </span><span style=color:#d08770>0xDD223344</span><span>;
</span><span>    uint32_t u32_out = u32_in;
</span><span>    uint32_t set_mask = </span><span style=color:#d08770>0x02000000</span><span>;     </span><span style=color:#65737e>// 25th bit is 1, everything else is 0
</span><span>    uint32_t clear_mask = </span><span style=color:#d08770>0xFFFFFFBF</span><span>;  </span><span style=color:#65737e>// 6th  bit is 0, everything else is 1
</span><span>
</span><span>    u32_out |= set_mask;    </span><span style=color:#65737e>// set   25th bit
</span><span>    u32_out &= clear_mask;  </span><span style=color:#65737e>// clear 6th bit
</span><span>
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>u32_in : %#b</span><span style=color:#96b5b4>\n</span><span>", u32_in);
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>u32_out: %#b</span><span style=color:#96b5b4>\n</span><span>", u32_out);
</span><span>
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span><span>
</span></code></pre><p><strong>Snippet 3 stdout:</strong><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>u32_in</span><span> : 0b11011101001000100011001101000100
</span><span style=color:#bf616a>u32_out:</span><span> 0b11011111001000100011001100000100
</span></code></pre><blockquote><p>From the above snippet, we can confirm that endianness comes into the picture only when we treat multibyte data as raw bytes, but doesnâ€™t matter when we operate using multi-byte operations directly.</blockquote><h2 id=real-world-scenarios>Real world scenarios</h2><h3 id=raw-memory-dumps>Raw memory dumps</h3><p>When we get memory dumps from GDB, QEMU, EEPROM and/or flash images, we should know beforehand which endian is used to store the data.<p><strong>Snippet 4:</strong><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>Memory</span><span> dump: 66 00 00 00
</span><span style=color:#bf616a>LE</span><span> â†’ 0x00000066 (102 decimal)
</span><span style=color:#bf616a>BE</span><span> â†’ 0x66000000 (1,711,276,032 decimal)
</span></code></pre><p>From the above snippet, we can confirm that if we had to read 32-bit data from the raw memory dump, we could end up with different values if we donâ€™t know how it was stored in the first place.<h3 id=elf>ELF</h3><p>Executable and Linkable Format (ELF) is a common file format for executables, object files, shared libraries, device drivers and core dumps. The fifth byte of the ELF header (e_ident[EI_DATA]) determines how to interpret all subsequent multi-byte fields (such as addresses, offsets, and sizes) in the entire file.<ul><li>Value 1: Specifies Little-endian encoding<li>Value 2: Specifies Big-endian encoding</ul><h3 id=network-protocols>Network protocols</h3><p>Most networking protocols use <code>network byte order</code> which is <code>big-endian</code>, but be careful out there because some network protocols use <code>little-endian</code> too.<h3 id=kerberos>Kerberos</h3><p><strong>Version 2</strong> of <code>Keytab file format</code> always uses big-endian byte order, whereas <strong>version 1</strong> uses native byte order for integer representations.<h3 id=binary-file-formats>Binary file formats</h3><p>Many binary file formats either encode the endian type or use a fixed endian type for that particular file format. So we have to consider this if we are dealing with raw binary formats in any form.<h2 id=conclusion>Conclusion</h2><ul><li>Full script is available on github <a href=https://github.com/Karthik-d-k/Karthik-d-k.github.io/blob/main/content/scripts/endianness_fiasco.c rel=noopener target=_blank><strong>endianness_fiasco.c</strong></a></ul><p class=tags-data><a href=/tags/c>/c/</a></main><footer><hr><footer id=footer><div id=contact-icons><a rel="noopener noreferrer" title="Subscribe via RSS for updates." class=no-style href=atom.xml target=_blank> <span class=iconify data-icon=solar:atom-bold></span> </a><a class=no-style href=mailto:karthikdk1998@gmail.com target=_blank title=Email> <span class=iconify data-icon=mdi:email></span> </a><a rel="noopener noreferrer" class=no-style href=https://github.com/Karthik-d-k target=_blank title=GitHub> <span class=iconify data-icon=mdi:github></span> </a><a rel="noopener noreferrer" class=no-style href=https://x.com/Karthik_d_k target=_blank title=Twitter> <span class=iconify data-icon=mdi:twitter></span> </a><a rel="noopener noreferrer" class=no-style href=https://www.linkedin.com/in/karthik-d-k-319853166 target=_blank title=LinkedIn> <span class=iconify data-icon=mdi:linkedin></span> </a></div><script src=https://code.iconify.design/2/2.2.1/iconify.min.js></script></footer></footer><div aria-hidden=true class=search-modal id=search-modal><div class=search-modal-backdrop></div><div class=search-modal-container><div class=search-modal-header><input enterkeyhint=search id=search-modal-input inputmode=search placeholder=Search... type=search><kbd class=search-modal-kbd>Ctrl+K</kbd></div><ul class=search-modal-results id=search-modal-results></ul><div class=search-modal-empty id=search-modal-empty style=display:none>No results found</div></div></div><script src=https://Karthik-d-k.github.io/elasticlunr.min.js></script><script>window.SEARCH_INDEX_URL = "https://Karthik-d-k.github.io/search_index.en.json";
          window.DEFAULT_THEME = "dark";</script>